\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\usepackage[margin=1in]{geometry}
\usepackage{hyperref}
\hypersetup{unicode=true,
            pdftitle={introduction},
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

%%% Use protect on footnotes to avoid problems with footnotes in titles
\let\rmarkdownfootnote\footnote%
\def\footnote{\protect\rmarkdownfootnote}

%%% Change title format to be more compact
\usepackage{titling}

% Create subtitle command for use in maketitle
\providecommand{\subtitle}[1]{
  \posttitle{
    \begin{center}\large#1\end{center}
    }
}

\setlength{\droptitle}{-2em}

  \title{introduction}
    \pretitle{\vspace{\droptitle}\centering\huge}
  \posttitle{\par}
    \author{}
    \preauthor{}\postauthor{}
    \date{}
    \predate{}\postdate{}
  

\begin{document}
\maketitle

\hypertarget{what-row-pattern-matching-is-for}{%
\subsection{What row pattern matching is
for}\label{what-row-pattern-matching-is-for}}

You can think of row pattern matching as a an advanced way of filtering
rows. Instead of filtering on some static condition like
\texttt{price\textgreater{}100} you can filter rows that are part of
some pattern - i.e.~pattern between rows. Say you have som stock data
(which conveniently is included with the package), you can select rows
that are part of a 5-or-more day price surge. Or, rows that are part of
a long zig-zag pattern. Or days that are part of a microcrack (this is
when the stock price plummets and recovers within a short time).

For social scientists dealing with panel data, which follows interview
subjects year after year, this lets you easily find things like repeated
job changes, periods of strong income increases, or specific educational
paths.

\hypertarget{about-this-package}{%
\subsection{About this package}\label{about-this-package}}

Although row pattern matching is an existing feature in some databases
and a part of ANSI:SQL 2016, \texttt{rowpatternmatcher} is not trying to
copy the ANSI row pattern matching syntax. Rather it is trying to copy
the functionality and adapt it to the R and tidyverse programming
patterns. Also, the implementation is fairly opportunistic. It leaves
out functionality that is covered by tidyverse libraries, it has some
new features that came ``for free'' in the R environment and the
specific implementation, and it postpones implementing features that
have a high cost/benefit ratio. All in all, it is likely that the
library will never cover all features of row pattern matching in SQL.

\hypertarget{the-theory}{%
\subsection{The theory}\label{the-theory}}

Basically, working with row pattern matching comes in two steps: 1.
First you create a set of \textbf{definitions} for your rows. To
continue the example above, this can be something like the close price
of a stock being higher than in the previous row, or the name of
someones employer being different from the next row. Or maybe as simple
as stock price over 100. For the time being, you can create up to 10 of
these definition (for weird technical reasons). Definitions are
basically just a new column, containing ``nicknames'' for your
definitions. In the example of stock prices, nicknames can be things
like \emph{UP} or \emph{DOWN}. These names are completely up to you, but
should be intuitive. 1. The definition column you created in the
previous step is in turn the basis for the \textbf{pattern} you will
define and look for. Defining a pattern can be done using pseudo-regex
(or real regex, for advanced users), and will return only the rows that
are part of the pattern you are looking for.

\hypertarget{a-simple-example}{%
\subsection{A simple example}\label{a-simple-example}}

Using the stock data that comes with the package, one interesting thing
we can find out is which stock has had the longest prolonged price
increase. For simplicity we decide that a price increase is when closing
price being higher than the day before.

First, we need to create some definitions, in our case two definitions
are enough: ``UP'' for when the price increases, and ``DOWN'' for when
it doesn't. We can do this with standard tidyverse functions. Two things
to keep in mind though: 1. Since the dataset contains different stocks,
we need to use \texttt{group\_by} so we don't compare one stock to the
other. 1. Since we compare sequences of rows, the ordering is important.
We will use \texttt{arrange} to make sure the rows are ordered.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{stocks_change <-}\StringTok{ }\NormalTok{stocks }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{group_by}\NormalTok{(ticker) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{arrange}\NormalTok{(date) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{mutate}\NormalTok{( }\DataTypeTok{change =} 
           \KeywordTok{case_when}\NormalTok{(}
\NormalTok{             adj_close}\OperatorTok{>}\KeywordTok{lag}\NormalTok{(adj_close) }\OperatorTok{~}\StringTok{ 'UP'}\NormalTok{,}
             \OtherTok{TRUE} \OperatorTok{~}\StringTok{ 'DOWN'}
\NormalTok{           )}
\NormalTok{  )}

\KeywordTok{head}\NormalTok{(stocks_change)}
\CommentTok{#> # A tibble: 6 x 9}
\CommentTok{#> # Groups:   ticker [3]}
\CommentTok{#>   date        open  high   low close adj_close   volume ticker change}
\CommentTok{#>   <fct>      <dbl> <dbl> <dbl> <dbl>     <dbl>    <int> <chr>  <chr> }
\CommentTok{#> 1 2018-08-30  112.  113.  111.  112.      110. 22798700 MSFT   DOWN  }
\CommentTok{#> 2 2018-08-30 1997. 2026. 1987. 2002.     2002.  7277300 AMZN   DOWN  }
\CommentTok{#> 3 2018-08-30  223.  228.  222.  225.      222. 48793800 AAPL   DOWN  }
\CommentTok{#> 4 2018-08-31  112.  113.  112.  112.      111. 23222700 MSFT   UP    }
\CommentTok{#> 5 2018-08-31 2007  2022. 2005. 2013.     2013.  4204400 AMZN   UP    }
\CommentTok{#> 6 2018-08-31  227.  229.  226   228.      224. 43340100 AAPL   UP}
\end{Highlighting}
\end{Shaded}

This creates a new dataframe with a new column, \texttt{change} that is
eiter ``UP'' or ``DOWN''. This is our definition, and as promised we can
create this using only tidyverse functions. If you are more comfortable
with base R or other libraries feel free to use that, but this library
is created to work with the tidyverse programming paradigm.

Now that we have our definition column, we can turn to writing the
pattern that we are looking for. Since we are looking for long series of
rows where the \texttt{change} column equals ``UP'', it makes sense to
look for any occurence of two-or-more UPs in a row. Our pattern, in
pseudo-regex, is therefore \texttt{UP\{2,\}}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{increases <-}\StringTok{ }\NormalTok{stocks_change }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{match_rows}\NormalTok{(change, }\StringTok{"UP\{2,\}"}\NormalTok{, }\DataTypeTok{match_name=}\NormalTok{matchnumber)}

\KeywordTok{head}\NormalTok{(increases)}
\CommentTok{#> # A tibble: 6 x 10}
\CommentTok{#> # Groups:   ticker [1]}
\CommentTok{#>   ticker date    open  high   low close adj_close volume change matchnumber}
\CommentTok{#>   <chr>  <fct>  <dbl> <dbl> <dbl> <dbl>     <dbl>  <int> <chr>        <int>}
\CommentTok{#> 1 AAPL   2018-~  227.  229.  226   228.      224. 4.33e7 UP               1}
\CommentTok{#> 2 AAPL   2018-~  228.  229.  227.  228.      225. 2.74e7 UP               1}
\CommentTok{#> 3 AAPL   2018-~  218.  222.  217.  218.      215. 3.16e7 UP               2}
\CommentTok{#> 4 AAPL   2018-~  218.  220.  215.  218.      215. 2.71e7 UP               2}
\CommentTok{#> 5 AAPL   2018-~  220.  222.  219.  220.      217. 2.66e7 UP               2}
\CommentTok{#> 6 AAPL   2018-~  217.  221.  217.  221.      217. 2.77e7 UP               3}
\end{Highlighting}
\end{Shaded}

Here, we have provided four arguments to the \texttt{match\_rows}
function: The data frame is piped in as the first argument, the second
argument is the column where our definitions are, the third argument is
the pattern we decided to look for (in quotes), and finally we have
provided an optional argument \texttt{match\_name} which when specified
returns a new variable containing the match number of the row. Since
there are probably many cases of UPs in a row for each stock, and we
want to find the longes streak, it helps us immensely to have this match
number. More on this later.

Now that we have selected the increases, lets's find the longest
increase for each stock. We can also include the start- and end-price.
We do this with standard dplyr-functions, and use the match number
variable together with ticker as grouping variables.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{increases }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{group_by}\NormalTok{(ticker, matchnumber) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{summarize}\NormalTok{(}\DataTypeTok{duration=}\KeywordTok{n}\NormalTok{(), }\DataTypeTok{price_increase=}\KeywordTok{last}\NormalTok{(adj_close)}\OperatorTok{-}\KeywordTok{first}\NormalTok{(adj_close)) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{summarize}\NormalTok{(}\DataTypeTok{max_duration=}\KeywordTok{max}\NormalTok{(duration), }\DataTypeTok{max_increase=}\KeywordTok{max}\NormalTok{(price_increase[}\DataTypeTok{duration=}\KeywordTok{max}\NormalTok{(duration)]))}
\CommentTok{#> # A tibble: 3 x 3}
\CommentTok{#>   ticker max_duration max_increase}
\CommentTok{#>   <chr>         <int>        <dbl>}
\CommentTok{#> 1 AAPL              9         1.83}
\CommentTok{#> 2 AMZN              7        96.4 }
\CommentTok{#> 3 MSFT              8         1.84}
\end{Highlighting}
\end{Shaded}

Interestingly, both Microsoft and Apple have had longer periods of
increases than amazon, but amazon has, had a much higher increase during
its longest streak.

\hypertarget{using-pure-regex}{%
\subsection{Using pure regex}\label{using-pure-regex}}

There is also an ``advanced mode'', which does not do any pre-parsing of
the regex and therefore allows for more advanced regex patterns to be
specified. The downside of this though, is that the definitions created
can only consist of a single character. This really shows that what
happens under the hood is pure regex, and one of the simplifying tricks
is to have a 1-to-1 mapping between the text string containing the
definitions and the rows. Sorry for the inconvenience, this is duct-tape
not magic.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{msft }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{match_rows_raw}\NormalTok{(change2, }\StringTok{'[U]\{4,\}[D]\{3,\}'}\NormalTok{, mnum) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{select}\NormalTok{(date, adj_close, change2, mnum)}
\CommentTok{#>          date adj_close change2 mnum}
\CommentTok{#> 46 2018-11-02  104.5176       U    1}
\CommentTok{#> 47 2018-11-05  105.8467       U    1}
\CommentTok{#> 48 2018-11-06  106.0535       U    1}
\CommentTok{#> 49 2018-11-07  110.2279       U    1}
\CommentTok{#> 50 2018-11-08  110.0211       D    1}
\CommentTok{#> 51 2018-11-09  107.8749       D    1}
\CommentTok{#> 52 2018-11-12  105.2167       D    1}
\CommentTok{#> 87 2019-01-04  100.7866       U    2}
\CommentTok{#> 88 2019-01-07  100.9151       U    2}
\CommentTok{#> 89 2019-01-08  101.6468       U    2}
\CommentTok{#> 90 2019-01-09  103.1004       U    2}
\CommentTok{#> 91 2019-01-10  102.4379       D    2}
\CommentTok{#> 92 2019-01-11  101.6468       D    2}
\CommentTok{#> 93 2019-01-14  100.9053       D    2}
\end{Highlighting}
\end{Shaded}

The example uses the \texttt{msft} dataset, which is already pre-sorted
and has a \texttt{change2} column containg a ``D'' for down and ``U''
for UP.

This pattern looks for occurences of the Microsoft stock increasing at
least four consecutive days, and then decreasing at least three
consecutive days.

\hypertarget{further-reading}{%
\subsection{Further reading}\label{further-reading}}

The concept was first developed (as far as I know) by Oracle, and was
included in the ANSI SQL:2016 standard. But so far very few databases
support it - despite it being one of the most creative new features in a
while.

If you want to learn more about row pattern matching as implemented by
Oracle, you can take a look at their documentation at
\url{https://docs.oracle.com/database/121/DWHSG/pattern.htm\#DWHSG8956}.


\end{document}
